0. 목표 정의

기존에 각자 만든 앱/웹을 수정 없이 유지합니다.

새로 만드는 것은 배포 어댑터(인덱스, 라우팅, 정적파일 경로, 리라이트/프록시, 서버리스 API) 뿐입니다.

산출물: 저장소 루트에 github-deploy/ 폴더를 신규 생성하고, 그 안에서 배포에 필요한 파일과 스크립트만 구성합니다.

1. 폴더 전략(단일 폴더에 다수 프로젝트 수용)

아래 구조는 “각자 만든 범용 앱/웹”이 여러 개 있어도, github-deploy 폴더에서 모두 실행·배포되도록 설계합니다.

repo-root/
├─ app1/                        # 기존 앱(수정 금지)
├─ app2/                        # 기존 앱(수정 금지)
├─ web1/                        # 기존 웹(수정 금지)
├─ web2/                        # 기존 웹(수정 금지)
└─ github-deploy/               # 신규: 깃허브/베르셀 배포 전용 어댑터 폴더
   ├─ index.html                # 선택 페이지(런처) - 각 프로젝트로 링크
   ├─ projects.json             # 런처가 읽는 프로젝트 목록/경로 정의
   ├─ public/                   # 정적 자원(파비콘 등)
   ├─ adapters/                 # 각 프로젝트별 어댑터(경로정리, 라우팅)
   │  ├─ app1/                  # app1 어댑터(심볼릭/복사본 or 빌드산출물)
   │  ├─ app2/
   │  ├─ web1/
   │  └─ web2/
   ├─ api/                      # Vercel 서버리스(API 프록시/헬스체크)
   │  ├─ health.js
   │  └─ proxy.js
   ├─ vercel.json               # Vercel 라우팅/리라이트/헤더 설정
   ├─ package.json              # 로컬 미리보기/검증 스크립트
   ├─ .gitignore
   ├─ README.md
   └─ scripts/
      ├─ prepare.sh             # 어댑터 폴더에 복제/경로보정 자동화
      └─ check.sh               # 링크/리소스/라우팅 사전 점검


핵심: github-deploy/adapters/* 안에는 “기존 프로젝트 원본”을 복제하거나, 이미 빌드가 있는 경우 “빌드 산출물”을 둡니다. 원본을 절대 훼손하지 않고, 어댑터에서만 경로 보정과 라우팅을 처리합니다.

2. 프로젝트 복제 자동화(prepare.sh)

github-deploy/scripts/prepare.sh를 실행하면, 각 프로젝트의 배포 대상 폴더를 자동 생성하고, 경로를 상대경로로 보정하며(필요 시), SPA 라우팅과 GitHub Pages 404 대응을 세팅합니다.

#!/usr/bin/env bash
set -e

# 배포할 대상 목록을 projects.json 에서 읽음
ROOT="$(cd "$(dirname "$0")/.." && pwd)"

echo "[prepare] github-deploy 어댑터를 준비합니다."
echo "[prepare] projects.json 읽는 중..."

PROJECTS=$(cat "$ROOT/projects.json" | sed -n 's/.*"path": *"\([^"]*\)".*/\1/p')

for P in $PROJECTS; do
  NAME=$(basename "$P")
  SRC="$ROOT/../$P"
  DST="$ROOT/adapters/$NAME"

  echo "[prepare] $NAME 복제 준비 -> $DST"

  rm -rf "$DST"
  mkdir -p "$DST"

  # 1) 빌드 산출물이 있는 경우 우선 사용 (dist|build)
  if [ -d "$SRC/dist" ]; then
    cp -R "$SRC/dist/." "$DST/"
  elif [ -d "$SRC/build" ]; then
    cp -R "$SRC/build/." "$DST/"
  else
    # 정적 사이트라면 원본 복제(HTML/CSS/JS만)
    rsync -av --exclude node_modules --exclude .git "$SRC/" "$DST/"
  fi

  # 2) SPA 라우팅 대응(404.html = index.html)
  if [ -f "$DST/index.html" ]; then
    cp "$DST/index.html" "$DST/404.html"
  fi

  # 3) 절대경로 → 상대경로 보정(간단 패턴)
  # <link href="/style.css"> 와 같은 루트 기준 경로를 ./ 으로 보정
  find "$DST" -type f -name "*.html" -print0 | xargs -0 sed -i \
    -e 's/href="\//href=".\/_/g' \
    -e 's/src="\//src=".\/_/g'
  # 보정 후 다시 되돌리는 후처리(./_ → ./)
  find "$DST" -type f -name "*.html" -print0 | xargs -0 sed -i \
    -e 's/\.\//\.\//g' -e 's/\.\/_/\.\//g'
done

echo "[prepare] 완료"


위 스크립트는 매우 보수적으로 동작합니다. SPA라면 404.html 복사 트릭으로 GitHub Pages 404 문제를 회피합니다. 절대경로 사용이 심한 경우엔 정규식 보정이 부족할 수 있으므로, 필요 시 패턴을 추가하세요.

3. 런처 페이지(index.html)와 프로젝트 목록(projects.json)

github-deploy/index.html은 사용자가 들어오면 “어느 프로젝트로 갈지” 선택하는 안전한 메인입니다. 링크만 제공하고, 각 프로젝트는 어댑터 폴더에서 독립적으로 동작합니다.

github-deploy/projects.json 예시:

[
  { "name": "app1", "path": "app1", "desc": "앱1 - 기존 UI/UX 100% 보존" },
  { "name": "app2", "path": "app2", "desc": "앱2 - 기존 UI/UX 100% 보존" },
  { "name": "web1", "path": "web1", "desc": "웹1 - 정적/SPA 혼합" },
  { "name": "web2", "path": "web2", "desc": "웹2 - 정적 사이트" }
]


github-deploy/index.html 최소 구현(프로젝트 자동 렌더):

<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>배포 런처</title>
  <style>
    body { font-family: system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto; margin:0; padding:24px; }
    .grid { display:grid; gap:12px; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); }
    .card { border:1px solid #e5e7eb; border-radius:12px; padding:16px; }
    a { text-decoration:none; color:#111827; }
    .name { font-weight:600; margin-bottom:6px; }
    .path { font-size:12px; color:#6b7280; }
  </style>
</head>
<body>
  <h1>프로젝트 런처</h1>
  <div id="list" class="grid"></div>
  <script>
    fetch('./projects.json').then(r=>r.json()).then(items=>{
      const el = document.getElementById('list');
      el.innerHTML = items.map(it=>`
        <a class="card" href="./adapters/${it.path}/">
          <div class="name">${it.name}</div>
          <div>${it.desc||''}</div>
          <div class="path">${it.path}</div>
        </a>
      `).join('');
    });
  </script>
</body>
</html>

4. Vercel 라우팅/프록시(vercel.json)와 서버리스 API

Vercel에서 각 프로젝트를 서브경로로 안전하게 서비스하고, 외부 API 프록시도 제공합니다.

github-deploy/vercel.json:

{
  "version": 2,
  "name": "multi-project-launcher",
  "public": true,
  "routes": [
    { "src": "^/api/health$", "dest": "/api/health.js" },
    { "src": "^/api/proxy/(.*)$", "dest": "/api/proxy.js" },

    { "src": "^/adapters/app1$", "status": 301, "headers": { "Location": "/adapters/app1/" } },
    { "src": "^/adapters/app2$", "status": 301, "headers": { "Location": "/adapters/app2/" } },
    { "src": "^/adapters/web1$", "status": 301, "headers": { "Location": "/adapters/web1/" } },
    { "src": "^/adapters/web2$", "status": 301, "headers": { "Location": "/adapters/web2/" } },

    { "src": "^/adapters/([^/]+)/?(.*)$", "dest": "/adapters/$1/$2" },

    { "src": "^/(.*\\.(css|js|png|jpg|jpeg|gif|svg|ico|webp|woff|woff2|ttf|map))$", "dest": "/$1",
      "headers": { "Cache-Control": "public, max-age=31536000, immutable" } },

    { "src": "^/$", "dest": "/index.html" },
    { "src": "^(?!/api)(.*)$", "dest": "/$1" }
  ],
  "headers": [
    { "source": "/(.*)", "headers": [
      { "key": "X-Content-Type-Options", "value": "nosniff" },
      { "key": "Referrer-Policy", "value": "strict-origin-when-cross-origin" }
    ]}
  ]
}


github-deploy/api/health.js:

export default function handler(req, res) {
  res.status(200).json({ ok: true, ts: Date.now() });
}


github-deploy/api/proxy.js(기본 프록시 예시):

export default async function handler(req, res) {
  const target = process.env.PROXY_TARGET; // 예: https://api.example.com
  if (!target) return res.status(500).json({ error: "PROXY_TARGET not set" });

  const u = new URL(req.url, `http://${req.headers.host}`);
  const path = u.pathname.replace(/^\/api\/proxy/, "");
  const dest = target + path + (u.search || "");

  const upstream = await fetch(dest, {
    method: req.method,
    headers: { ...Object.fromEntries(Object.entries(req.headers)
      .filter(([k]) => !["host","connection","content-length"].includes(k.toLowerCase()))) },
    body: ["GET","HEAD"].includes(req.method) ? undefined : req
  });

  res.status(upstream.status);
  upstream.headers.forEach((v,k)=>res.setHeader(k,v));
  upstream.body.pipe(res);
}


외부 API CORS 문제가 있다면, 프론트는 /api/proxy/... 로 호출하고, 환경변수 PROXY_TARGET 를 Vercel 대시보드에 설정합니다.

5. GitHub Pages 대응(404, 브랜치, 서브경로)

Pages 소스: Settings > Pages > Source: GitHub Actions 또는 Branch: main, Folder: /github-deploy.

SPA일 경우: adapters/* 내에 index.html 을 404.html 로 복사해 라우팅 깨짐을 방지합니다.

링크/리소스 경로는 반드시 상대경로(./) 를 우선합니다. 절대경로(/)는 Pages 서브경로에서 깨질 수 있습니다.

커스텀 도메인 사용 시 CNAME 설정 후 DNS(A/ALIAS or CNAME) 적용을 확인합니다.

6. package.json(로컬 미리보기 및 점검)

github-deploy/package.json:

{
  "name": "github-deploy-adapter",
  "private": true,
  "scripts": {
    "prepare": "bash ./scripts/prepare.sh",
    "check": "bash ./scripts/check.sh",
    "dev": "npx http-server -p 5173 -c-1 .",
    "start": "npm run dev",
    "vercel-build": "echo Build by prepare && npm run prepare"
  },
  "devDependencies": {}
}


github-deploy/scripts/check.sh(간단 점검):

#!/usr/bin/env bash
set -e
ROOT="$(cd "$(dirname "$0")/.." && pwd)"
echo "[check] 링크/파일 존재 여부 기본 점검"
# 필요시 htmlhint, linkinator 등 도입 가능
[ -f "$ROOT/index.html" ] || (echo "index.html 없음" && exit 1)
[ -d "$ROOT/adapters" ] || (echo "adapters 폴더 없음" && exit 1)
echo "[check] OK"

7. Git 히스토리 및 업로드 절차

최초 1회

cd repo-root/github-deploy
npm run prepare
npm run check
git add github-deploy
git commit -m "deploy: add github-deploy adapter (no UI/UX changes)"
git push origin main


Vercel 연결

Vercel에서 New Project → 해당 저장소 선택 → Framework: Other → Build Command: npm run vercel-build → Output: 자동.

환경변수 필요 시 PROXY_TARGET 등 설정.

GitHub Pages 연결

Settings > Pages > Branch 기반으로 github-deploy 노출 또는 GitHub Actions로 배포.

8. 다종 프로젝트 케이스별 규칙

정적 사이트(HTML/CSS/JS):

prepare.sh가 그대로 복제.

루트 절대경로를 상대경로로 쓰는지 확인.

SPA(React/Vue/Svelte 등):

원본 빌드 산출물(dist/build)을 어댑터로 가져옵니다.

GitHub Pages용 404 대체파일 생성.

라우팅은 Vercel에서 서브경로로 정상 동작.

백엔드 의존(전통 서버):

직접 배포 대신 프론트는 /api/proxy/* 로 호출.

Vercel 서버리스에서 외부 API 프록시로 연결.

CORS/인증은 서버 측 정책 고려.

에셋 경로:

HTML/CSS/JS 내부 경로는 ./assets/... 처럼 상대경로 사용이 안전합니다.

빌드 도구가 publicPath(또는 base) 설정을 지원하면 서브경로 배포를 고려해 ./ 로 설정합니다.

9. 품질 체크리스트

프로젝트 복제 전

각 프로젝트 로컬에서 정상 구동/빌드 여부 확인.

외부 API 엔드포인트, 키, CORS 등 점검.

npm run prepare 후

adapters/* 안에 index.html 존재 확인.

SPA는 404.html 동시 존재 확인.

이미지/CSS/JS 200 응답 확인.

상대경로로 리소스 로드되는지 확인.

배포 후

GitHub Pages 서브경로에서 브라우저 뒤로가기, 리프레시 시 정상 동작 확인.

Vercel의 /api/health 200 확인.

/api/proxy 경유 외부 API 호출 검증.

10. 문제 해결 가이드

GitHub Pages 404:

해당 서브경로에서 SPA 리프레시 시 404면 404.html이 누락된 것.

브랜치/폴더 설정이 루트가 아닌 경우 경로가 절대경로로 되어 있으면 깨집니다.

스타일/이미지 미표시:

절대경로(/style.css)를 상대(./style.css)로 교체.

CSS 안의 url(/images/...) 또한 상대 경로로 교체 필요.

Vercel에서만 API OK, Pages에서는 실패:

Pages는 서버리스가 없습니다. API는 Vercel 도메인을 호출하도록 분기하거나 프록시를 사용하세요.

커스텀 도메인:

DNS 적용 후 HTTPS 인증서 발급까지 잠시 대기.

CNAME 또는 A 레코드 설정 확인.

11. README 템플릿(요약용)

github-deploy/README.md:

# GitHub/Vercel 배포 어댑터

본 폴더는 기존 프로젝트(UI/UX/기능 변경 없음)를 그대로 유지한 채, 배포에 필요한 최소한의 파일과 라우팅/프록시만 제공합니다.

## 사용법
1) projects.json 에 대상 목록과 경로를 등록
2) `npm run prepare` 실행 → adapters/* 에 빌드/복제
3) `npm run dev` 로 로컬 확인
4) GitHub Pages 또는 Vercel에 연결

## 규칙
- 절대경로 대신 상대경로 우선
- SPA는 404.html = index.html 복사
- 외부 API는 `/api/proxy/*` 로 경유

12. 최소 변경 원칙 검증

기존 코드에 손대지 않기(원본 폴더는 그대로).

경로 보정은 어댑터 복제본에서만 수행.

라우팅/프록시는 배포 폴더에서만 설정.

13. 바로 쓰는 실행 순서(요약)

github-deploy/ 생성 및 위 파일들 배치

projects.json 에 대상 프로젝트들 경로 등록

npm run prepare 로 어댑터 생성

npm run dev 로 로컬 확인

저장소 푸시 → Vercel 연결 → 배포

GitHub Pages 연결(필요 시)

체크리스트로 링크/라우팅/이미지 최종 점검

원하시면 위 구조와 파일을 바로 만들 수 있도록 템플릿 압축본을 생성해 드리겠습니다. 또한 현재 보유하신 각 프로젝트 유형(정적/SPA/백엔드 의존)에 맞춰 prepare.sh의 보정 규칙을 더 정교화해 드릴 수 있습니다.
