# GitHub/Vercel 배포 어댑터 지침서

본 지침서는 기존에 개발된 웹/앱 프로젝트의 UI/UX 및 기능을 그대로 유지하면서, GitHub Pages 및 Vercel을 통한 효율적인 배포 및 서빙을 위한 자동화된 가이드라인을 제공합니다. 각 프로젝트의 원본 코드를 수정하지 않고, 배포에 필요한 최소한의 파일과 라우팅/프록시 설정을 `github-deploy` 폴더 내에서 관리하여, 세상에서 가장 완벽한 배포 및 서빙 환경을 구축하는 것을 목표로 합니다.

## 목차

1.  **개요 및 목표**
    *   기존 프로젝트 유지 원칙
    *   `github-deploy` 폴더의 역할과 중요성
    *   배포 및 서빙 자동화의 이점

2.  **프로젝트 구조 및 폴더 전략**
    *   `repo-root` 및 `github-deploy` 폴더 구조 상세 설명
    *   단일 폴더에 다수 프로젝트 수용 전략
    *   `adapters` 폴더의 역할과 원본 프로젝트와의 관계

3.  **프로젝트 복제 및 경로 보정 자동화 (`prepare.sh`)**
    *   `prepare.sh` 스크립트의 기능 및 동작 원리
    *   빌드 산출물 처리 (dist/build)
    *   정적 사이트 복제 및 상대 경로 보정
    *   SPA 라우팅 대응 (404.html)

4.  **런처 페이지 (`index.html`) 및 프로젝트 목록 (`projects.json`)**
    *   `index.html`의 역할 및 최소 구현 예시
    *   `projects.json`을 통한 프로젝트 목록 관리
    *   프로젝트 자동 렌더링 스크립트 설명

5.  **Vercel 라우팅, 프록시 및 서버리스 API (`vercel.json`, `api/`)**
    *   `vercel.json`을 통한 라우팅, 리라이트, 헤더 설정
    *   Vercel 서버리스 기능 활용 (health check, proxy)
    *   외부 API CORS 문제 해결을 위한 프록시 설정 (`api/proxy.js`)

6.  **GitHub Pages 대응 전략**
    *   GitHub Pages 소스 설정 (GitHub Actions 또는 Branch)
    *   SPA를 위한 404.html 복사 트릭
    *   상대 경로 사용의 중요성
    *   커스텀 도메인 설정

7.  **로컬 미리보기 및 점검 (`package.json`, `check.sh`)**
    *   `package.json` 스크립트 (prepare, check, dev, start, vercel-build)
    *   `check.sh`를 통한 링크/파일 존재 여부 기본 점검
    *   추가적인 품질 점검 도구 소개

8.  **Git 히스토리 및 업로드 절차**
    *   최초 1회 설정 및 Git 커밋/푸시 절차
    *   Vercel 프로젝트 연결 및 환경변수 설정
    *   GitHub Pages 연결 및 설정

9.  **다종 프로젝트 케이스별 규칙**
    *   정적 사이트 배포 규칙
    *   SPA (React/Vue/Svelte 등) 배포 규칙
    *   백엔드 의존 프로젝트 (전통 서버) 배포 규칙
    *   에셋 경로 처리 가이드라인

10. **품질 체크리스트 및 문제 해결 가이드**
    *   프로젝트 복제 전/후 체크리스트
    *   배포 후 최종 점검 사항
    *   GitHub Pages 404, 스타일/이미지 미표시, API 호출 문제 해결
    *   커스텀 도메인 문제 해결

11. **최소 변경 원칙 검증**
    *   기존 코드에 손대지 않기
    *   경로 보정 및 라우팅/프록시 설정의 범위

12. **바로 쓰는 실행 순서 (요약)**
    *   `github-deploy` 생성 및 파일 배치
    *   `projects.json` 등록
    *   `npm run prepare` 및 `npm run dev`
    *   저장소 푸시 및 Vercel/GitHub Pages 연결
    *   최종 점검

## 시작하기

이 지침서는 여러분의 기존 프로젝트를 웹 서비스로 배포하고 서빙하는 과정을 획기적으로 단순화하고 자동화하는 데 도움을 줄 것입니다. 다음 섹션부터 각 단계별 상세 내용을 확인하고 따라해보세요.





## 1. 개요 및 목표

이 지침서는 기존에 개발된 웹 애플리케이션 또는 모바일 애플리케이션 프로젝트의 핵심 UI/UX 및 기능을 전혀 변경하지 않고, 이를 GitHub Pages 및 Vercel과 같은 최신 배포 플랫폼을 통해 효율적으로 배포하고 서비스할 수 있도록 돕는 자동화된 가이드라인을 제공합니다. 우리의 주된 목표는 개발자가 기존의 개발 산출물에 대한 수정 부담 없이, 빠르고 안정적으로 프로젝트를 웹 서비스 형태로 전환하고 배포할 수 있는 환경을 구축하는 것입니다.

### 기존 프로젝트 유지 원칙

가장 중요한 원칙은 '기존 프로젝트의 무결성 유지'입니다. 여러분이 이미 개발해 놓은 웹 또는 앱 프로젝트의 소스 코드는 이 지침서의 과정에서 어떠한 수정도 가해지지 않습니다. 이는 개발자가 익숙한 개발 환경과 워크플로우를 그대로 유지하면서도, 배포 및 서빙이라는 새로운 요구사항을 충족시킬 수 있도록 하기 위함입니다. 우리는 원본 프로젝트를 '복제'하거나 '빌드 산출물'을 활용하여 배포 환경을 구성하며, 이 과정에서 발생하는 모든 경로나 설정 변경은 별도의 '어댑터' 계층에서 처리됩니다.

### `github-deploy` 폴더의 역할과 중요성

`github-deploy` 폴더는 이 지침서의 핵심적인 구성 요소입니다. 이 폴더는 여러분의 기존 프로젝트를 GitHub Pages나 Vercel과 같은 정적/서버리스 호스팅 환경에 최적화하여 배포하기 위한 모든 파일과 스크립트를 담고 있습니다. 이 폴더는 다음과 같은 중요한 역할을 수행합니다.

*   **배포 전용 환경**: 기존 프로젝트의 복사본 또는 빌드 산출물을 담고, 배포 플랫폼의 요구사항에 맞춰 경로를 조정하거나 라우팅 규칙을 정의합니다.
*   **자동화 스크립트 포함**: 프로젝트 복제, 경로 보정, 배포 전 검증 등 일련의 과정을 자동화하는 스크립트(`prepare.sh`, `check.sh` 등)를 포함합니다.
*   **플랫폼 설정 파일**: Vercel의 `vercel.json`과 같이 특정 배포 플랫폼의 동작을 정의하는 설정 파일을 관리합니다.
*   **독립성 보장**: 기존 프로젝트와 완전히 분리되어 있어, `github-deploy` 폴더 내의 변경 사항이 원본 프로젝트에 영향을 주지 않습니다.

이 폴더는 GitHub 저장소의 루트에 위치하며, 이 폴더만으로도 웹 서비스가 즉시 구동될 수 있는 환경을 제공합니다. 이는 마치 기존 프로젝트 위에 배포를 위한 '얇은 어댑터 레이어'를 씌우는 것과 같습니다.

### 배포 및 서빙 자동화의 이점

이 지침서가 제공하는 자동화된 배포 및 서빙 시스템은 다음과 같은 이점을 제공합니다.

*   **개발 생산성 향상**: 배포 과정의 복잡성을 줄여 개발자가 핵심 기능 개발에 집중할 수 있도록 합니다.
*   **빠른 배포 및 업데이트**: 스크립트 실행 한 번으로 프로젝트를 배포 준비 상태로 만들고, Git 푸시를 통해 즉시 업데이트를 반영할 수 있습니다.
*   **유지보수 용이성**: 배포 관련 설정과 스크립트가 한 곳에 모여 있어 관리 및 유지보수가 용이합니다.
*   **확장성**: 단일 `github-deploy` 폴더 내에서 여러 개의 프로젝트를 동시에 관리하고 배포할 수 있는 구조를 제공하여, 다양한 프로젝트를 효율적으로 서빙할 수 있습니다.
*   **안정성**: 검증된 스크립트와 설정 파일을 통해 배포 과정에서의 오류를 최소화하고 안정적인 서비스 운영을 지원합니다.

이 지침서를 통해 여러분은 기존의 소중한 개발 산출물을 웹 서비스 형태로 손쉽게 전환하고, 전 세계 사용자들에게 제공할 수 있는 강력한 도구를 얻게 될 것입니다. 다음 섹션에서는 `github-deploy` 폴더의 상세 구조와 각 구성 요소의 역할에 대해 더 깊이 있게 다룹니다.





## 2. 프로젝트 구조 및 폴더 전략

효율적인 배포 및 관리를 위해, 이 지침서는 명확하고 체계적인 프로젝트 구조를 제안합니다. 특히, 여러 개의 독립적인 웹 또는 앱 프로젝트를 단일 GitHub 저장소 내에서 관리하고 배포할 수 있도록 설계된 `github-deploy` 폴더 전략이 핵심입니다. 이 섹션에서는 전체 저장소의 구조와 `github-deploy` 폴더 내부의 상세 구성, 그리고 각 요소의 역할을 설명합니다.

### `repo-root` 및 `github-deploy` 폴더 구조 상세 설명

여러분의 GitHub 저장소는 일반적으로 다음과 같은 `repo-root` 구조를 가질 것입니다. 여기서 `app1`, `web1` 등은 여러분이 기존에 개발한 프로젝트 폴더를 의미하며, 이들은 어떠한 수정도 없이 그대로 유지됩니다. 새로 생성되는 `github-deploy` 폴더는 이 `repo-root`의 최상위 경로에 위치합니다.

```
repo-root/
├─ app1/                        # 기존 앱 프로젝트 (수정 금지)
├─ app2/                        # 기존 앱 프로젝트 (수정 금지)
├─ web1/                        # 기존 웹 프로젝트 (수정 금지)
├─ web2/                        # 기존 웹 프로젝트 (수정 금지)
└─ github-deploy/               # 신규: 깃허브/베르셀 배포 전용 어댑터 폴더
   ├─ index.html                # 런처 페이지 (각 프로젝트로의 링크 제공)
   ├─ projects.json             # 런처가 읽는 프로젝트 목록 및 경로 정의
   ├─ public/                   # 정적 자원 (파비콘, 공통 이미지 등)
   ├─ adapters/                 # 각 프로젝트별 배포 어댑터 폴더
   │  ├─ app1/                  # app1의 복사본 또는 빌드 산출물
   │  ├─ app2/
   │  ├─ web1/
   │  └─ web2/
   ├─ api/                      # Vercel 서버리스 함수 (API 프록시, 헬스체크)
   │  ├─ health.js
   │  └─ proxy.js
   ├─ vercel.json               # Vercel 라우팅, 리라이트, 헤더 설정
   ├─ package.json              # 로컬 미리보기 및 검증 스크립트
   ├─ .gitignore
   ├─ README.md                 # 이 지침서가 포함될 README 파일
   └─ scripts/                  # 자동화 스크립트
      ├─ prepare.sh             # 프로젝트 복제 및 경로 보정 자동화 스크립트
      └─ check.sh               # 링크/리소스/라우팅 사전 점검 스크립트
```

이 구조에서 가장 중요한 점은 `app1`, `web1`과 같은 기존 프로젝트 폴더는 `github-deploy` 폴더와 완전히 독립적으로 존재하며, `github-deploy` 폴더 내에서만 배포를 위한 작업이 이루어진다는 것입니다. 이는 원본 프로젝트의 개발 흐름에 전혀 영향을 주지 않으면서 배포 환경을 구축할 수 있게 합니다.

### 단일 폴더에 다수 프로젝트 수용 전략

`github-deploy` 폴더는 단일 GitHub 저장소 내에서 여러 개의 독립적인 프로젝트를 동시에 배포하고 서비스할 수 있도록 설계되었습니다. 이는 `projects.json` 파일과 `adapters/` 폴더의 유기적인 조합을 통해 가능해집니다.

*   **`projects.json`**: 이 파일은 `github-deploy` 폴더 내에서 관리되는 모든 프로젝트의 목록과 해당 프로젝트의 경로, 그리고 간단한 설명을 JSON 형식으로 정의합니다. `index.html` (런처 페이지)는 이 `projects.json` 파일을 읽어 동적으로 프로젝트 목록을 생성하고, 각 프로젝트로 이동할 수 있는 링크를 제공합니다.
*   **`adapters/` 폴더**: 이 폴더는 `projects.json`에 정의된 각 프로젝트의 실제 배포 가능한 산출물(복사본 또는 빌드 결과물)을 담는 공간입니다. `prepare.sh` 스크립트가 실행되면, 각 원본 프로젝트의 내용이 이 `adapters/` 폴더 내의 해당 프로젝트 이름으로 된 하위 폴더로 복제되거나 빌드 산출물이 이동됩니다. 예를 들어, `app1` 프로젝트의 배포 산출물은 `github-deploy/adapters/app1/` 경로에 위치하게 됩니다.

이러한 구조를 통해, 여러분은 하나의 GitHub 저장소에 여러 개의 웹/앱 프로젝트를 관리하면서도, 단일 배포 지점(`github-deploy` 폴더)을 통해 모든 프로젝트를 효율적으로 서빙할 수 있습니다. 이는 특히 포트폴리오 사이트나 여러 개의 소규모 프로젝트를 한 번에 관리하고자 할 때 매우 유용합니다.

### `adapters` 폴더의 역할과 원본 프로젝트와의 관계

`adapters` 폴더는 `github-deploy` 전략의 핵심적인 부분으로, 원본 프로젝트와 배포 환경 사이의 '어댑터' 역할을 수행합니다. 이 폴더의 주요 특징과 원본 프로젝트와의 관계는 다음과 같습니다.

*   **원본 훼손 방지**: `adapters` 폴더 내에 위치하는 각 프로젝트의 내용은 원본 프로젝트의 복사본이거나 빌드된 산출물입니다. 따라서 `adapters` 폴더 내에서 발생하는 모든 경로 보정, 라우팅 설정 등의 변경 사항은 원본 프로젝트에 전혀 영향을 주지 않습니다. 이는 원본 코드를 안전하게 보호하면서 배포 환경을 유연하게 구성할 수 있게 합니다.
*   **다양한 프로젝트 유형 지원**: `prepare.sh` 스크립트는 정적 HTML/CSS/JS 사이트, React/Vue/Svelte와 같은 SPA(Single Page Application), 심지어 백엔드 의존적인 프론트엔드 프로젝트까지 다양한 유형의 프로젝트를 `adapters` 폴더로 가져올 수 있도록 설계되었습니다. SPA의 경우 빌드 산출물(`dist` 또는 `build` 폴더)을 우선적으로 복사하며, 정적 사이트의 경우 필요한 파일들만 선별적으로 복사합니다.
*   **경로 보정 및 라우팅 처리**: `adapters` 폴더로 복제된 프로젝트의 내부 링크나 리소스 경로는 배포 환경에 맞게 자동으로 보정될 수 있습니다. 특히 GitHub Pages와 같이 서브 경로에서 서비스되는 환경에서는 절대 경로(`/<path>`) 대신 상대 경로(`./<path>`)를 사용하는 것이 중요하며, `prepare.sh` 스크립트는 이러한 경로 보정을 지원합니다. 또한, SPA의 경우 404 에러 페이지를 `index.html`로 복사하여 클라이언트 측 라우팅이 정상적으로 동작하도록 합니다.

결론적으로, `adapters` 폴더는 기존 프로젝트의 코드를 변경하지 않고도, GitHub Pages나 Vercel과 같은 현대적인 배포 플랫폼의 요구사항에 맞춰 프로젝트를 유연하게 변환하고 서비스할 수 있도록 하는 핵심적인 중간 계층입니다. 다음 섹션에서는 이 `adapters` 폴더를 자동으로 구성하는 `prepare.sh` 스크립트의 상세 기능에 대해 다룹니다.





## 3. 프로젝트 복제 및 경로 보정 자동화 (`prepare.sh`)

`github-deploy` 전략의 핵심적인 자동화 요소는 바로 `scripts/prepare.sh` 스크립트입니다. 이 스크립트는 여러분의 기존 프로젝트를 `github-deploy/adapters/` 폴더로 안전하게 복제하고, 배포 환경에 최적화된 형태로 경로를 보정하는 일련의 과정을 자동화합니다. 이 섹션에서는 `prepare.sh` 스크립트의 기능, 동작 원리, 그리고 각 프로젝트 유형에 따른 처리 방식에 대해 상세히 설명합니다.

### `prepare.sh` 스크립트의 기능 및 동작 원리

`prepare.sh` 스크립트는 `github-deploy` 폴더의 루트에서 `npm run prepare` 명령을 통해 실행됩니다. 이 스크립트의 주요 기능은 다음과 같습니다.

1.  **프로젝트 목록 읽기**: `github-deploy/projects.json` 파일을 읽어 배포할 프로젝트들의 목록과 해당 프로젝트의 원본 경로를 파악합니다. 이 `projects.json` 파일은 여러분이 수동으로 관리하며, 어떤 프로젝트를 배포할지 스크립트에 알려주는 역할을 합니다.
2.  **대상 폴더 생성 및 초기화**: 각 프로젝트에 대해 `github-deploy/adapters/<project_name>/` 경로에 새로운 폴더를 생성하고, 이전에 존재했던 내용을 삭제하여 항상 깨끗한 상태에서 복제 작업을 시작합니다.
3.  **원본 프로젝트 복제 또는 빌드 산출물 이동**: 각 프로젝트의 유형에 따라 원본 프로젝트를 복제하거나, 이미 빌드된 산출물(예: `dist` 또는 `build` 폴더)을 `adapters` 폴더로 가져옵니다. 이 과정에서 `node_modules`나 `.git`과 같은 불필요한 파일들은 제외하여 배포본의 크기를 최소화합니다.
4.  **SPA 라우팅 대응 (404.html)**: SPA(Single Page Application)의 경우, GitHub Pages와 같은 환경에서 클라이언트 측 라우팅이 정상적으로 동작하도록 `index.html` 파일을 `404.html`로 복사합니다. 이는 사용자가 특정 경로로 직접 접근했을 때 404 에러 대신 `index.html`이 로드되어 SPA 라우터가 경로를 처리할 수 있도록 하는 트릭입니다.
5.  **상대 경로 보정**: HTML 파일 내의 절대 경로(`href="/path/to/resource"`, `src="/path/to/image.png"`)를 상대 경로(`href="./path/to/resource"`, `src="./path/to/image.png"`)로 자동 보정합니다. 이는 GitHub Pages와 같이 서브 경로에서 서비스될 때 리소스 로딩 문제가 발생하는 것을 방지하기 위함입니다. 스크립트는 기본적인 정규식을 사용하여 이 작업을 수행하며, 복잡한 경로 구조의 경우 추가적인 정규식 패턴이 필요할 수 있습니다.

스크립트의 동작은 매우 보수적이며, 원본 프로젝트를 훼손하지 않는 것을 최우선으로 합니다. 모든 작업은 `adapters` 폴더 내에서만 이루어집니다.

### 빌드 산출물 처리 (dist/build)

React, Vue, Angular, Svelte 등 대부분의 현대적인 프론트엔드 프레임워크는 배포를 위해 프로젝트를 빌드합니다. 빌드 과정은 소스 코드를 최적화된 정적 파일(HTML, CSS, JavaScript, 이미지 등)로 변환하여 `dist` 또는 `build`와 같은 특정 폴더에 저장합니다. `prepare.sh` 스크립트는 이러한 빌드 산출물을 우선적으로 처리하도록 설계되었습니다.

스크립트는 각 프로젝트 폴더 내에 `dist` 또는 `build` 폴더가 존재하는지 확인하고, 만약 존재한다면 해당 폴더의 내용을 `github-deploy/adapters/<project_name>/` 폴더로 그대로 복사합니다. 이는 빌드된 최적화된 버전을 직접 배포에 활용함으로써, 불필요한 파일 복사를 줄이고 배포 효율성을 높이는 방법입니다.

```bash
# 1) 빌드 산출물이 있는 경우 우선 사용 (dist|build)
if [ -d "$SRC/dist" ]; then
  cp -R "$SRC/dist/." "$DST/"
elif [ -d "$SRC/build" ]; then
  cp -R "$SRC/build/." "$DST/"
# ...
fi
```

### 정적 사이트 복제 및 상대 경로 보정

빌드 과정이 없는 순수한 정적 HTML/CSS/JS 웹사이트의 경우, `prepare.sh` 스크립트는 원본 프로젝트 폴더의 내용을 `adapters` 폴더로 직접 복사합니다. 이때 `rsync` 명령어를 사용하여 `node_modules`나 `.git`과 같은 개발 및 버전 관리 관련 폴더는 제외합니다. 이는 배포본에 불필요한 파일이 포함되는 것을 방지합니다.

```bash
# ...
else
  # 정적 사이트라면 원본 복제(HTML/CSS/JS만)
  rsync -av --exclude node_modules --exclude .git "$SRC/" "$DST/"
fi
```

복제된 정적 사이트의 HTML 파일 내에 절대 경로로 지정된 리소스(CSS, JavaScript, 이미지 등)가 있다면, 스크립트는 이를 상대 경로로 자동 보정합니다. 이는 특히 GitHub Pages와 같이 사용자 정의 도메인 없이 서브 경로(`username.github.io/repo-name/`)로 서비스될 때, 리소스 로딩 오류를 방지하는 데 필수적입니다.

```bash
# 3) 절대경로 → 상대경로 보정(간단 패턴)
# <link href="/style.css"> 와 같은 루트 기준 경로를 ./ 으로 보정
find "$DST" -type f -name "*.html" -print0 | xargs -0 sed -i \
  -e 's/href="\//href=".\/_/g' \
  -e 's/src="\//src=".\/_/g'
# 보정 후 다시 되돌리는 후처리(./_ → ./)
find "$DST" -type f -name "*.html" -print0 | xargs -0 sed -i \
  -e 's/\.\//\.\//g' -e 's/\.\/_/\.\//g'
```

이 `sed` 명령어는 `/`로 시작하는 `href`나 `src` 속성 값을 `./_`로 임시 변경한 후, 다시 `./`로 최종 변경하는 방식으로 동작합니다. 이는 경로 보정 과정에서 발생할 수 있는 잠재적인 문제를 최소화하기 위한 보수적인 접근 방식입니다.

### SPA 라우팅 대응 (404.html)

SPA는 클라이언트 측에서 JavaScript를 사용하여 경로를 관리합니다. 하지만 GitHub Pages와 같은 정적 호스팅 환경에서는 사용자가 특정 서브 경로(예: `username.github.io/repo-name/about`)로 직접 접근하거나 페이지를 새로고침할 경우, 서버는 해당 경로에 대한 파일을 찾지 못하고 404 에러를 반환하게 됩니다. 이는 SPA의 클라이언트 측 라우팅이 동작하기 전에 서버에서 파일이 없다고 판단하기 때문입니다.

`prepare.sh` 스크립트는 이 문제를 해결하기 위해 간단하지만 효과적인 트릭을 사용합니다. `adapters` 폴더 내에 `index.html` 파일이 존재한다면, 이 파일을 `404.html`이라는 이름으로 복사합니다.

```bash
# 2) SPA 라우팅 대응(404.html = index.html)
if [ -f "$DST/index.html" ]; then
  cp "$DST/index.html" "$DST/404.html"
fi
```

GitHub Pages는 404 에러가 발생했을 때 `404.html` 파일을 자동으로 서빙하는 기능을 제공합니다. 따라서 사용자가 어떤 경로로 접근하든 파일이 없으면 `404.html` (즉, `index.html`의 복사본)이 로드되고, `index.html` 내의 JavaScript가 실행되어 클라이언트 측 라우팅이 정상적으로 경로를 처리하게 됩니다. 이로써 SPA의 라우팅 문제가 해결되고, 사용자 경험이 향상됩니다.

`prepare.sh` 스크립트는 이처럼 다양한 프로젝트 유형과 배포 환경의 특성을 고려하여, 여러분의 프로젝트를 GitHub Pages 및 Vercel에 최적화된 형태로 변환하는 강력한 자동화 도구입니다. 다음 섹션에서는 사용자가 배포된 프로젝트를 쉽게 탐색할 수 있도록 돕는 런처 페이지와 프로젝트 목록 관리에 대해 설명합니다.





## 4. 런처 페이지 (`index.html`) 및 프로젝트 목록 (`projects.json`)

`github-deploy` 폴더의 핵심적인 사용자 인터페이스는 바로 런처 페이지인 `index.html`입니다. 이 페이지는 사용자가 배포된 환경에 처음 접근했을 때 마주하게 되는 메인 화면으로, `projects.json` 파일에 정의된 프로젝트 목록을 동적으로 불러와 각 프로젝트로 이동할 수 있는 링크를 제공합니다. 이 섹션에서는 런처 페이지의 역할, `projects.json`의 구조, 그리고 이들이 어떻게 상호작용하여 사용자에게 편리한 탐색 경험을 제공하는지 설명합니다.

### `index.html`의 역할 및 최소 구현 예시

`github-deploy/index.html` 파일은 사용자가 배포된 환경의 루트 URL(예: `https://your-username.github.io/your-repo/` 또는 `https://your-vercel-domain.vercel.app/`)로 접근했을 때 가장 먼저 로드되는 페이지입니다. 이 페이지의 주된 역할은 다음과 같습니다.

*   **프로젝트 게이트웨이**: 단일 배포 환경 내에 존재하는 여러 프로젝트들을 사용자에게 명확하게 제시하고, 각 프로젝트로의 진입점을 제공합니다.
*   **안전한 진입점**: 각 프로젝트가 독립적인 경로(`adapters/<project_name>/`)에서 동작하므로, 런처 페이지는 프로젝트 간의 충돌 없이 안전하게 접근할 수 있는 중앙 허브 역할을 합니다.
*   **동적 목록 생성**: `projects.json` 파일의 내용을 기반으로 프로젝트 목록을 동적으로 생성하여, 새로운 프로젝트가 추가되거나 기존 프로젝트가 변경되어도 `index.html` 파일을 직접 수정할 필요가 없습니다.

다음은 `index.html`의 최소 구현 예시입니다. 이 코드는 `projects.json` 파일을 비동기적으로 불러와 프로젝트 목록을 웹 페이지에 카드 형태로 렌더링합니다.

```html
<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>배포 런처</title>
  <style>
    body { font-family: system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto; margin:0; padding:24px; }
    .grid { display:grid; gap:12px; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); }
    .card { border:1px solid #e5e7eb; border-radius:12px; padding:16px; }
    a { text-decoration:none; color:#111827; }
    .name { font-weight:600; margin-bottom:6px; }
    .path { font-size:12px; color:#6b7280; }
  </style>
</head>
<body>
  <h1>프로젝트 런처</h1>
  <div id="list" class="grid"></div>
  <script>
    fetch('./projects.json').then(r=>r.json()).then(items=>{
      const el = document.getElementById('list');
      el.innerHTML = items.map(it=>`
        <a class="card" href="./adapters/${it.path}/">
          <div class="name">${it.name}</div>
          <div>${it.desc||''}</div>
          <div class="path">${it.path}</div>
        </a>
      `).join('');
    });
  </script>
</body>
</html>
```

이 HTML 파일은 최소한의 CSS 스타일링을 포함하여 기본적인 레이아웃을 제공하며, JavaScript를 사용하여 `projects.json`에서 데이터를 가져와 `id="list"`를 가진 `div` 요소 내에 프로젝트 카드들을 생성합니다. 각 카드는 프로젝트 이름, 설명, 그리고 `adapters/<project_path>/`로 연결되는 링크를 포함합니다.

### `projects.json`을 통한 프로젝트 목록 관리

`github-deploy/projects.json` 파일은 런처 페이지가 동적으로 프로젝트 목록을 생성하는 데 필요한 데이터를 제공하는 JSON 형식의 파일입니다. 이 파일은 배열 형태로 각 프로젝트에 대한 객체를 포함하며, 각 객체는 다음과 같은 속성을 가집니다.

*   `name`: 프로젝트의 사용자 친화적인 이름입니다. 런처 페이지에 표시됩니다.
*   `path`: `github-deploy/adapters/` 폴더 내에서 해당 프로젝트의 실제 경로를 나타냅니다. 이 값은 `prepare.sh` 스크립트가 프로젝트를 복제할 때 사용하는 이름과 일치해야 합니다.
*   `desc` (선택 사항): 프로젝트에 대한 간략한 설명입니다. 런처 페이지에 프로젝트 이름 아래에 표시될 수 있습니다.

다음은 `projects.json` 파일의 예시입니다.

```json
[
  { "name": "app1", "path": "app1", "desc": "앱1 - 기존 UI/UX 100% 보존" },
  { "name": "app2", "path": "app2", "desc": "앱2 - 기존 UI/UX 100% 보존" },
  { "name": "web1", "path": "web1", "desc": "웹1 - 정적/SPA 혼합" },
  { "name": "web2", "path": "web2", "desc": "웹2 - 정적 사이트" }
]
```

새로운 프로젝트를 배포 환경에 추가하려면, 단순히 이 `projects.json` 파일에 해당 프로젝트의 정보를 추가하고 `prepare.sh` 스크립트를 다시 실행하면 됩니다. 런처 페이지는 자동으로 업데이트된 목록을 반영하여 새로운 프로젝트 카드를 표시할 것입니다.

### 프로젝트 자동 렌더링 스크립트 설명

`index.html` 내의 JavaScript 코드는 `fetch` API를 사용하여 `projects.json` 파일을 비동기적으로 로드합니다. 데이터가 성공적으로 로드되면, `map` 함수를 사용하여 각 프로젝트 객체를 HTML 문자열로 변환하고, 이들을 `join('')`으로 연결하여 최종 HTML 콘텐츠를 생성합니다. 생성된 HTML은 `document.getElementById('list').innerHTML`을 통해 `div` 요소에 삽입되어 웹 페이지에 프로젝트 목록이 동적으로 렌더링됩니다.

이러한 방식은 다음과 같은 장점을 가집니다.

*   **유연성**: `projects.json`만 수정하면 되므로, 프로젝트 목록을 쉽게 추가, 제거 또는 수정할 수 있습니다.
*   **유지보수 용이성**: HTML 구조와 데이터가 분리되어 있어, 코드의 가독성과 유지보수성이 향상됩니다.
*   **확장성**: 향후 프로젝트 목록을 필터링하거나 검색하는 등의 추가 기능을 쉽게 구현할 수 있습니다.

런처 페이지와 `projects.json`의 조합은 단일 배포 환경에서 여러 프로젝트를 효율적으로 관리하고 사용자에게 직관적인 탐색 경험을 제공하는 데 필수적인 요소입니다. 다음 섹션에서는 Vercel 환경에서 라우팅, 프록시, 서버리스 API를 설정하는 방법에 대해 자세히 설명합니다.





## 5. Vercel 라우팅, 프록시 및 서버리스 API (`vercel.json`, `api/`)

Vercel은 현대적인 웹 애플리케이션 배포를 위한 강력한 플랫폼으로, 정적 사이트 호스팅뿐만 아니라 서버리스 함수, 고급 라우팅 및 프록시 기능을 제공합니다. `github-deploy` 전략에서는 `vercel.json` 파일을 통해 Vercel의 이러한 기능을 최대한 활용하여, 단일 배포 환경에서 여러 프로젝트를 서브 경로로 안전하게 서비스하고, 외부 API와의 연동 문제를 해결합니다. 이 섹션에서는 `vercel.json`의 구성과 서버리스 API의 활용 방안에 대해 상세히 설명합니다.

### `vercel.json`을 통한 라우팅, 리라이트, 헤더 설정

`github-deploy/vercel.json` 파일은 Vercel 배포 시 적용될 라우팅 규칙, URL 재작성(rewrite), HTTP 헤더 설정 등을 정의하는 핵심 구성 파일입니다. 이 파일은 JSON 형식으로 작성되며, 다음과 같은 주요 섹션으로 구성됩니다.

*   **`version`**: Vercel 설정 파일의 버전을 지정합니다. 일반적으로 `2`를 사용합니다.
*   **`name`**: Vercel 프로젝트의 이름을 지정합니다.
*   **`public`**: 프로젝트가 공개적으로 접근 가능한지 여부를 설정합니다. `true`로 설정하면 공개됩니다.
*   **`routes`**: 가장 중요한 섹션으로, 들어오는 요청 URL 패턴(`src`)에 따라 어떤 목적지(`dest`)로 라우팅할지, 또는 어떤 동작을 수행할지 정의합니다. 정규 표현식을 사용하여 유연한 라우팅 규칙을 설정할 수 있습니다.
    *   **서버리스 API 라우팅**: `/api/health` 및 `/api/proxy`와 같은 서버리스 함수로의 요청을 해당 JavaScript 파일로 연결합니다.
    *   **프로젝트 서브 경로 리다이렉트**: `^/adapters/app1$`와 같이 `/`로 끝나지 않는 프로젝트 경로 요청을 `/`로 끝나는 경로로 301 리다이렉트하여 일관된 URL을 유지합니다.
    *   **프로젝트 서브 경로 라우팅**: `^/adapters/([^/]+)/?(.*)$`와 같은 패턴을 사용하여 `adapters` 폴더 내의 각 프로젝트로 요청을 라우팅합니다. 이는 `adapters/app1/index.html`과 같은 실제 파일 경로로 연결됩니다.
    *   **정적 자원 캐싱**: `.css`, `.js`, 이미지 파일 등 정적 자원에 대해 `Cache-Control` 헤더를 설정하여 브라우저 캐싱을 최적화하고 성능을 향상시킵니다.
    *   **루트 경로 및 폴백 라우팅**: 루트 경로(`^/$`) 요청을 `index.html` (런처 페이지)로 연결하고, 그 외의 모든 요청(`^(?!/api)(.*)$`)을 `$1` (요청된 경로 그대로)로 라우팅하여 정적 파일 서빙을 처리합니다.
*   **`headers`**: 모든 응답에 공통적으로 적용될 HTTP 헤더를 정의합니다. 보안 관련 헤더(예: `X-Content-Type-Options`, `Referrer-Policy`)를 설정하여 웹 애플리케이션의 보안을 강화할 수 있습니다.

다음은 `vercel.json` 파일의 예시입니다.

```json
{
  "version": 2,
  "name": "multi-project-launcher",
  "public": true,
  "routes": [
    { "src": "^/api/health$", "dest": "/api/health.js" },
    { "src": "^/api/proxy/(.*)$", "dest": "/api/proxy.js" },

    { "src": "^/adapters/app1$", "status": 301, "headers": { "Location": "/adapters/app1/" } },
    { "src": "^/adapters/app2$", "status": 301, "headers": { "Location": "/adapters/app2/" } },
    { "src": "^/adapters/web1$", "status": 301, "headers": { "Location": "/adapters/web1/" } },
    { "src": "^/adapters/web2$", "status": 301, "headers": { "Location": "/adapters/web2/" } },

    { "src": "^/adapters/([^/]+)/?(.*)$", "dest": "/adapters/$1/$2" },

    { "src": "^/(.*\\.(css|js|png|jpg|jpeg|gif|svg|ico|webp|woff|woff2|ttf|map))$", "dest": "/$1",
      "headers": { "Cache-Control": "public, max-age=31536000, immutable" } },

    { "src": "^/$", "dest": "/index.html" },
    { "src": "^(?!/api)(.*)$", "dest": "/$1" }
  ],
  "headers": [
    { "source": "/(.*)", "headers": [
      { "key": "X-Content-Type-Options", "value": "nosniff" },
      { "key": "Referrer-Policy", "value": "strict-origin-when-cross-origin" }
    ]}
  ]
}
```

### Vercel 서버리스 기능 활용 (health check, proxy)

Vercel은 별도의 서버를 관리할 필요 없이, 요청이 있을 때만 실행되는 서버리스 함수를 지원합니다. `github-deploy` 폴더 내의 `api/` 디렉토리에 JavaScript 파일을 생성하면, Vercel은 이를 자동으로 서버리스 함수로 인식하고 배포합니다. 이 지침서에서는 두 가지 주요 서버리스 함수를 활용합니다.

#### `api/health.js` (헬스 체크)

이 함수는 배포된 서비스의 상태를 확인하는 간단한 엔드포인트로 사용됩니다. Vercel 배포 후 서비스가 정상적으로 동작하는지 확인할 때 유용합니다.

```javascript
export default function handler(req, res) {
  res.status(200).json({ ok: true, ts: Date.now() });
}
```

`vercel.json`의 라우팅 규칙에 따라 `/api/health` 경로로 요청이 들어오면 이 함수가 실행되며, `200 OK` 상태 코드와 함께 현재 시간을 포함한 JSON 응답을 반환합니다.

#### `api/proxy.js` (외부 API 프록시)

프론트엔드 애플리케이션에서 외부 API를 직접 호출할 때 CORS(Cross-Origin Resource Sharing) 문제에 직면하는 경우가 많습니다. `api/proxy.js` 함수는 이러한 CORS 문제를 해결하기 위한 프록시 서버 역할을 수행합니다. 프론트엔드에서 `/api/proxy/` 경로로 요청을 보내면, 이 서버리스 함수가 실제 외부 API로 요청을 전달하고 응답을 받아 프론트엔드로 다시 전달합니다.

```javascript
export default async function handler(req, res) {
  const target = process.env.PROXY_TARGET; // 예: https://api.example.com
  if (!target) return res.status(500).json({ error: "PROXY_TARGET not set" });

  const u = new URL(req.url, `http://${req.headers.host}`);
  const path = u.pathname.replace(/^\/api\/proxy/, "");
  const dest = target + path + (u.search || "");

  const upstream = await fetch(dest, {
    method: req.method,
    headers: { ...Object.fromEntries(Object.entries(req.headers)
      .filter(([k]) => !["host","connection","content-length"].includes(k.toLowerCase()))) },
    body: ["GET","HEAD"].includes(req.method) ? undefined : req
  });

  res.status(upstream.status);
  upstream.headers.forEach((v,k)=>res.setHeader(k,v));
  upstream.body.pipe(res);
}
```

이 프록시 함수를 사용하려면, Vercel 대시보드에서 `PROXY_TARGET`이라는 환경 변수를 설정해야 합니다. 이 환경 변수에는 프록시할 실제 외부 API의 기본 URL(예: `https://api.example.com`)을 지정합니다. 프론트엔드에서는 `fetch('/api/proxy/your-api-endpoint')`와 같이 호출하면, Vercel 서버리스 함수가 이 요청을 `PROXY_TARGET/your-api-endpoint`로 변환하여 대신 호출해줍니다.

### 외부 API CORS 문제 해결을 위한 프록시 설정 (`api/proxy.js`)

CORS는 웹 브라우저가 보안상의 이유로 다른 출처(도메인, 프로토콜, 포트)의 리소스에 접근하는 것을 제한하는 메커니즘입니다. 프론트엔드 애플리케이션이 배포된 도메인과 다른 도메인의 API를 직접 호출하려고 할 때 CORS 오류가 발생할 수 있습니다. `api/proxy.js`는 이 문제를 서버 측 프록시를 통해 우회합니다.

프론트엔드 요청 -> Vercel 서버리스 프록시 -> 외부 API

이러한 흐름을 통해 브라우저는 동일 출처(`vercel.app` 도메인)의 서버리스 함수와 통신하게 되므로 CORS 제약에서 벗어날 수 있습니다. 서버리스 함수는 서버 환경에서 외부 API를 호출하므로 CORS 제약이 적용되지 않습니다. 이 방식은 프론트엔드 개발자가 복잡한 CORS 설정이나 백엔드 변경 없이도 외부 API를 안전하게 사용할 수 있도록 돕는 강력한 솔루션입니다.

`vercel.json`과 `api/` 폴더 내의 서버리스 함수들은 `github-deploy` 프로젝트가 Vercel 환경에서 유연하고 강력하게 동작할 수 있도록 하는 핵심적인 요소입니다. 다음 섹션에서는 GitHub Pages 환경에서의 배포 전략과 고려사항에 대해 다룹니다.





## 6. GitHub Pages 대응 전략

GitHub Pages는 GitHub 저장소에서 직접 정적 웹사이트를 호스팅할 수 있도록 해주는 서비스입니다. `github-deploy` 전략은 GitHub Pages 환경에서도 여러분의 프로젝트가 원활하게 서비스될 수 있도록 여러 가지 대응 방안을 포함하고 있습니다. 이 섹션에서는 GitHub Pages의 설정 방법, SPA 라우팅 문제 해결, 상대 경로 사용의 중요성, 그리고 커스텀 도메인 설정에 대해 상세히 설명합니다.

### GitHub Pages 소스 설정 (GitHub Actions 또는 Branch)

GitHub Pages를 활성화하려면 저장소 설정에서 Pages 소스를 지정해야 합니다. 두 가지 주요 옵션이 있습니다.

1.  **Branch 배포**: 가장 간단한 방법으로, 특정 브랜치(예: `main` 또는 `gh-pages`)의 특정 폴더(예: `/docs` 또는 `/root`)를 Pages의 소스로 지정할 수 있습니다. `github-deploy` 전략에서는 `main` 브랜치의 `/github-deploy` 폴더를 소스로 지정하는 것을 권장합니다.
    *   **설정 경로**: GitHub 저장소 > `Settings` > `Pages` > `Build and deployment` 섹션에서 `Source`를 `Deploy from a branch`로 선택하고, `Branch`를 `main`으로, `Folder`를 `/github-deploy`로 설정합니다.
2.  **GitHub Actions 배포**: 더 유연하고 강력한 방법으로, GitHub Actions 워크플로우를 사용하여 Pages를 배포할 수 있습니다. 이는 빌드 과정이 필요하거나, 더 복잡한 배포 로직을 구현해야 할 때 유용합니다. `github-deploy` 전략의 `prepare.sh` 스크립트와 연동하여 자동화된 배포 파이프라인을 구축할 수 있습니다.
    *   **설정 경로**: GitHub 저장소 > `Settings` > `Pages` > `Build and deployment` 섹션에서 `Source`를 `GitHub Actions`로 선택합니다. 이후 `.github/workflows` 폴더에 Pages 배포를 위한 워크플로우 파일을 생성해야 합니다.

어떤 방법을 선택하든, `github-deploy` 폴더의 내용이 GitHub Pages 서버로 정확히 배포되도록 설정하는 것이 중요합니다.

### SPA를 위한 404.html 복사 트릭

앞서 `prepare.sh` 섹션에서 설명했듯이, SPA(Single Page Application)는 클라이언트 측 라우팅을 사용하기 때문에 GitHub Pages와 같은 정적 호스팅 환경에서 새로고침 시 404 에러가 발생할 수 있습니다. GitHub Pages는 기본적으로 요청된 경로에 해당하는 파일이 없으면 404 에러 페이지를 반환합니다.

이 문제를 해결하기 위해 `prepare.sh` 스크립트는 SPA의 `index.html` 파일을 `404.html`로 복사합니다. GitHub Pages는 404 에러 발생 시 `404.html` 파일을 서빙하는 특성이 있습니다. 따라서 사용자가 어떤 경로로 직접 접근하든, 파일이 없으면 `index.html`의 내용이 담긴 `404.html`이 로드되고, 이 `index.html` 내의 JavaScript가 실행되어 SPA 라우터가 올바른 경로를 처리하게 됩니다. 이로써 SPA의 라우팅이 GitHub Pages에서도 정상적으로 동작하게 됩니다.

### 상대 경로 사용의 중요성

GitHub Pages는 기본적으로 저장소 이름이 포함된 서브 경로(예: `https://your-username.github.io/your-repo-name/`)로 서비스됩니다. 만약 여러분의 웹 프로젝트에서 `/style.css`와 같이 루트를 기준으로 하는 절대 경로를 사용한다면, 이는 `https://your-username.github.io/style.css`를 의미하게 되어 실제 파일 경로인 `https://your-username.github.io/your-repo-name/style.css`와 불일치하여 리소스 로딩 오류가 발생합니다.

따라서 `github-deploy` 전략에서는 `prepare.sh` 스크립트를 통해 HTML, CSS, JavaScript 파일 내의 모든 리소스 경로를 `./style.css`와 같은 **상대 경로**로 보정하는 것을 강조합니다. 상대 경로는 현재 문서의 위치를 기준으로 리소스의 위치를 지정하므로, 어떤 서브 경로에서 서비스되더라도 항상 올바른 리소스를 참조할 수 있게 합니다.

*   **HTML**: `<link href="./style.css">`, `<script src="./main.js"></script>`, `<img src="./images/logo.png">`
*   **CSS**: `background-image: url('./images/background.jpg');`

빌드 도구를 사용하는 SPA의 경우, 빌드 설정에서 `publicPath` 또는 `base` 옵션을 `./`로 설정하여 빌드 시점에 모든 경로가 상대 경로로 생성되도록 하는 것이 가장 이상적입니다.

### 커스텀 도메인 설정

GitHub Pages는 기본적으로 `username.github.io` 또는 `username.github.io/repo-name` 형태의 URL을 제공하지만, 사용자 정의 도메인(예: `www.your-domain.com`)을 연결할 수도 있습니다. 커스텀 도메인을 사용하면 서브 경로 문제가 자연스럽게 해결되므로, 프로젝트 내에서 절대 경로를 사용해도 문제가 발생하지 않습니다.

**설정 절차**: (GitHub Pages 설정에서 `Custom domain` 섹션)

1.  **CNAME 파일 생성**: `github-deploy` 폴더의 루트에 `CNAME`이라는 이름의 파일을 생성하고, 그 안에 여러분의 커스텀 도메인 이름(예: `www.your-domain.com`)을 한 줄로 작성합니다.
2.  **DNS 설정**: 도메인 등록 업체(DNS 제공자)에서 여러분의 도메인에 대한 DNS 레코드를 설정합니다.
    *   `www` 서브도메인을 사용하는 경우: `CNAME` 레코드를 생성하고, `www`를 `username.github.io`로 연결합니다.
    *   루트 도메인(apex domain, 예: `your-domain.com`)을 사용하는 경우: `A` 레코드를 생성하고, GitHub Pages의 IP 주소(GitHub Pages 문서에서 최신 IP 주소 확인)로 연결합니다. 또는 `ALIAS`/`ANAME` 레코드를 사용하여 `username.github.io`로 연결할 수도 있습니다.
3.  **GitHub Pages 설정 업데이트**: GitHub 저장소의 Pages 설정에서 `Custom domain` 필드에 여러분의 커스텀 도메인을 입력하고 저장합니다.
4.  **HTTPS 적용 확인**: DNS 설정이 전파되고 GitHub Pages에서 도메인을 인식하면, 자동으로 HTTPS 인증서가 발급됩니다. 이 과정은 몇 분에서 몇 시간까지 소요될 수 있습니다.

커스텀 도메인을 사용하면 URL이 깔끔해지고, 서브 경로로 인한 복잡성을 피할 수 있어 더욱 전문적인 웹 서비스를 제공할 수 있습니다. 다음 섹션에서는 `github-deploy` 프로젝트의 로컬 미리보기 및 점검을 위한 `package.json` 스크립트와 `check.sh` 스크립트에 대해 설명합니다.





## 7. 로컬 미리보기 및 점검 (`package.json`, `check.sh`)

`github-deploy` 폴더는 GitHub Pages나 Vercel에 배포하기 전에 로컬 환경에서 프로젝트를 미리 보고, 배포될 산출물의 유효성을 점검할 수 있는 도구들을 포함하고 있습니다. 이는 배포 후 발생할 수 있는 문제를 사전에 방지하고 개발 효율성을 높이는 데 기여합니다. 이 섹션에서는 `package.json`에 정의된 스크립트와 `scripts/check.sh` 스크립트의 역할 및 사용법에 대해 상세히 설명합니다.

### `package.json` 스크립트 (prepare, check, dev, start, vercel-build)

`github-deploy/package.json` 파일은 Node.js 프로젝트에서 사용되는 메타데이터 및 스크립트 정의 파일입니다. 이 파일은 `github-deploy` 폴더 내에서 실행될 다양한 명령어를 간편하게 관리하고 실행할 수 있도록 `scripts` 섹션을 포함합니다.

```json
{
  "name": "github-deploy-adapter",
  "private": true,
  "scripts": {
    "prepare": "bash ./scripts/prepare.sh",
    "check": "bash ./scripts/check.sh",
    "dev": "npx http-server -p 5173 -c-1 .",
    "start": "npm run dev",
    "vercel-build": "echo Build by prepare && npm run prepare"
  },
  "devDependencies": {}
}
```

각 스크립트의 역할은 다음과 같습니다.

*   **`prepare`**: `npm run prepare` 명령을 실행하면 `scripts/prepare.sh` 스크립트가 실행됩니다. 이 스크립트는 앞서 설명했듯이 `projects.json`에 정의된 프로젝트들을 `adapters` 폴더로 복제하고, 경로를 보정하며, SPA를 위한 `404.html`을 생성하는 등 배포 준비 작업을 자동화합니다. 이 스크립트는 배포 전 반드시 실행되어야 합니다.
*   **`check`**: `npm run check` 명령을 실행하면 `scripts/check.sh` 스크립트가 실행됩니다. 이 스크립트는 `github-deploy` 폴더 내의 주요 파일 및 폴더의 존재 여부를 확인하는 기본적인 유효성 검사를 수행합니다. 이는 배포 전 필수적인 파일들이 누락되지 않았는지 확인하는 데 도움을 줍니다.
*   **`dev`**: `npm run dev` 명령은 `npx http-server -p 5173 -c-1 .`를 실행하여 현재 디렉토리(`github-deploy/`)를 루트로 하는 간단한 로컬 웹 서버를 띄웁니다. 이 서버는 `5173` 포트에서 동작하며, 캐싱을 비활성화(`-c-1`)하여 항상 최신 파일을 로드하도록 합니다. 이를 통해 배포될 웹사이트의 모습을 로컬 환경에서 미리 확인할 수 있습니다. `http-server`는 Node.js 기반의 경량 웹 서버로, `npx`를 통해 별도 설치 없이 실행할 수 있습니다.
*   **`start`**: `npm run start`는 단순히 `npm run dev`를 호출하는 별칭 스크립트입니다. 이는 `dev` 스크립트와 동일하게 로컬 웹 서버를 시작합니다.
*   **`vercel-build`**: 이 스크립트는 Vercel 배포 시 Vercel 빌드 환경에서 실행될 명령어를 정의합니다. `echo Build by prepare && npm run prepare`는 Vercel이 빌드를 시작할 때 `prepare` 스크립트를 실행하도록 지시합니다. 이는 Vercel이 `github-deploy` 저장소를 클론한 후, `adapters` 폴더를 채우고 필요한 경로 보정을 수행하도록 하여, Vercel 환경에서도 프로젝트가 올바르게 빌드되고 배포될 수 있도록 합니다.

이러한 `package.json` 스크립트들을 활용하면, 개발자는 일관된 명령어로 배포 준비, 로컬 테스트, 그리고 실제 배포 과정을 효율적으로 관리할 수 있습니다.

### `check.sh`를 통한 링크/파일 존재 여부 기본 점검

`scripts/check.sh` 스크립트는 `github-deploy` 폴더 내의 핵심 파일 및 폴더의 존재 여부를 확인하여, 배포 전 기본적인 환경이 올바르게 설정되었는지 검증합니다. 이 스크립트는 `npm run check` 명령을 통해 실행됩니다.

```bash
#!/usr/bin/env bash
set -e
ROOT="$(cd "$(dirname "$0")/.." && pwd)"
echo "[check] 링크/파일 존재 여부 기본 점검"
# 필요시 htmlhint, linkinator 등 도입 가능
[ -f "$ROOT/index.html" ] || (echo "index.html 없음" && exit 1)
[ -d "$ROOT/adapters" ] || (echo "adapters 폴더 없음" && exit 1)
echo "[check] OK"
```

현재 `check.sh`는 다음과 같은 기본적인 검사를 수행합니다.

*   `index.html` 파일의 존재 여부 확인
*   `adapters` 폴더의 존재 여부 확인

만약 이 중 하나라도 만족하지 못하면 스크립트는 오류 메시지를 출력하고 종료됩니다. 이는 배포에 필수적인 파일이나 폴더가 누락되었을 때 이를 즉시 감지하여 문제를 해결할 수 있도록 돕습니다.

### 추가적인 품질 점검 도구 소개

`check.sh`는 기본적인 파일 존재 여부만 확인하지만, 더 견고한 배포를 위해서는 다음과 같은 추가적인 품질 점검 도구를 도입하는 것을 고려할 수 있습니다.

*   **`htmlhint`**: HTML 코드의 문법 오류, 접근성 문제, 비표준 태그 사용 등을 검사하여 HTML 품질을 향상시킵니다.
*   **`linkinator`**: 웹사이트 내의 깨진 링크(broken links)를 찾아주는 도구입니다. 배포된 웹사이트의 모든 내부 및 외부 링크가 정상적으로 작동하는지 확인할 때 유용합니다.
*   **`lighthouse` (또는 `web.dev/measure`)**: 웹사이트의 성능, 접근성, 모범 사례, SEO 등을 종합적으로 평가하고 개선 방안을 제시하는 도구입니다. Vercel에 배포된 후 실제 서비스 환경에서 성능을 측정하는 데 활용할 수 있습니다.
*   **`prettier` / `eslint`**: 코드 포맷팅 및 스타일 가이드를 강제하여 코드의 일관성과 가독성을 높입니다. 이는 특히 여러 개발자가 협업하는 프로젝트에서 중요합니다.

이러한 도구들을 `package.json` 스크립트에 통합하거나 GitHub Actions 워크플로우에 추가하여, 배포 파이프라인의 각 단계에서 자동화된 품질 검사를 수행할 수 있습니다. 이는 최종 사용자에게 제공되는 서비스의 품질을 보장하는 데 큰 도움이 됩니다.

로컬 미리보기 및 점검 단계는 실제 배포 전에 잠재적인 문제를 발견하고 수정할 수 있는 중요한 기회를 제공합니다. 다음 섹션에서는 `github-deploy` 폴더를 GitHub 저장소에 업로드하고 Vercel 및 GitHub Pages에 연결하는 구체적인 절차에 대해 설명합니다.





## 8. Git 히스토리 및 업로드 절차

`github-deploy` 폴더를 생성하고 필요한 파일들을 구성한 후에는, 이를 여러분의 GitHub 저장소에 커밋하고 푸시하는 과정이 필요합니다. 이 섹션에서는 `github-deploy` 폴더를 Git 저장소에 추가하는 절차, 그리고 Vercel 및 GitHub Pages와 연동하여 자동 배포를 설정하는 방법에 대해 상세히 설명합니다.

### 최초 1회 설정 및 Git 커밋/푸시 절차

`github-deploy` 폴더는 기존 프로젝트의 소스 코드와는 독립적으로 관리되어야 합니다. 따라서 이 폴더를 Git 저장소에 추가할 때는 기존 프로젝트의 Git 히스토리에 영향을 주지 않으면서, `github-deploy` 폴더 자체의 변경 이력을 명확하게 관리하는 것이 중요합니다.

다음은 `github-deploy` 폴더를 Git 저장소에 추가하고 푸시하는 일반적인 절차입니다.

1.  **`github-deploy` 폴더로 이동**: 터미널 또는 명령 프롬프트에서 `repo-root` (GitHub 저장소의 최상위 디렉토리)로 이동한 후, `github-deploy` 폴더로 들어갑니다.
    ```bash
    cd repo-root/github-deploy
    ```

2.  **배포 준비 스크립트 실행**: `npm run prepare` 명령을 실행하여 `adapters` 폴더에 프로젝트 복사본 또는 빌드 산출물을 생성하고, 필요한 경로 보정 작업을 수행합니다. 이 단계는 배포될 실제 내용이 준비되는 과정입니다.
    ```bash
    npm run prepare
    ```

3.  **기본 점검 스크립트 실행**: `npm run check` 명령을 실행하여 `github-deploy` 폴더 내의 핵심 파일들이 올바르게 준비되었는지 확인합니다. 이는 배포 전 기본적인 유효성 검사입니다.
    ```bash
    npm run check
    ```

4.  **Git에 변경 사항 추가**: `github-deploy` 폴더 내에서 발생한 모든 변경 사항(새로 생성된 파일, 수정된 파일 등)을 Git 스테이징 영역에 추가합니다. `repo-root`에서 `git add github-deploy` 명령을 사용하면 `github-deploy` 폴더 전체를 한 번에 추가할 수 있습니다.
    ```bash
    # repo-root/ 에서 실행
    git add github-deploy
    ```

5.  **변경 사항 커밋**: 추가된 변경 사항을 Git 저장소에 커밋합니다. 커밋 메시지는 `github-deploy` 폴더의 추가 또는 업데이트임을 명확히 나타내는 것이 좋습니다. 



    ```bash
    git commit -m "deploy: add github-deploy adapter (initial setup)"
    ```
    만약 `github-deploy` 폴더의 내용이 업데이트된 경우라면, `deploy: update github-deploy adapter`와 같이 메시지를 작성할 수 있습니다.

6.  **원격 저장소에 푸시**: 로컬 저장소의 변경 사항을 GitHub의 원격 저장소로 푸시합니다. `main` 브랜치에 푸시하는 것이 일반적입니다.
    ```bash
    git push origin main
    ```

이 절차를 통해 `github-deploy` 폴더의 모든 내용이 GitHub 저장소에 안전하게 업로드됩니다. 이제 이 저장소를 Vercel 및 GitHub Pages와 연동하여 자동 배포를 설정할 수 있습니다.

### Vercel 프로젝트 연결 및 환경변수 설정

Vercel은 GitHub 저장소와의 연동을 통해 커밋이 발생할 때마다 자동으로 프로젝트를 빌드하고 배포하는 기능을 제공합니다. `github-deploy` 프로젝트를 Vercel에 연결하는 절차는 다음과 같습니다.

1.  **Vercel 대시보드 로그인**: Vercel 웹사이트(`vercel.com`)에 접속하여 로그인합니다.
2.  **새 프로젝트 생성**: 대시보드에서 `New Project` 버튼을 클릭합니다.
3.  **Git 저장소 연결**: `Import Git Repository` 섹션에서 `github-deploy` 폴더가 포함된 GitHub 저장소를 선택하고 `Import` 버튼을 클릭합니다.
4.  **프로젝트 설정**: 프로젝트 설정 단계에서 다음을 확인하거나 설정합니다.
    *   **Framework Preset**: `Other`를 선택합니다. `github-deploy`는 특정 프레임워크에 종속되지 않는 범용적인 배포 어댑터이기 때문입니다.
    *   **Root Directory**: `github-deploy/`로 설정합니다. Vercel이 이 폴더를 프로젝트의 루트로 인식하도록 합니다.
    *   **Build Command**: `npm run vercel-build`로 설정합니다. 이 명령은 `package.json`에 정의되어 있으며, `prepare.sh` 스크립트를 실행하여 배포에 필요한 파일들을 준비합니다.
    *   **Output Directory**: Vercel이 자동으로 감지하므로 별도로 설정할 필요가 없습니다.
    *   **Environment Variables**: `api/proxy.js`와 같은 서버리스 함수에서 필요한 환경 변수(예: `PROXY_TARGET`)가 있다면, 이 섹션에서 추가합니다. `Key`와 `Value`를 입력하고 `Add` 버튼을 클릭합니다.
5.  **배포**: 모든 설정을 마친 후 `Deploy` 버튼을 클릭하면 Vercel이 프로젝트를 빌드하고 배포를 시작합니다. 첫 배포 후에는 GitHub 저장소에 새로운 커밋이 푸시될 때마다 Vercel이 자동으로 재배포를 수행합니다.

### GitHub Pages 연결 및 설정

GitHub Pages는 Vercel과 마찬가지로 GitHub 저장소의 내용을 기반으로 정적 웹사이트를 호스팅합니다. `github-deploy` 프로젝트를 GitHub Pages에 연결하는 절차는 다음과 같습니다.

1.  **GitHub 저장소 설정 접속**: GitHub 저장소 페이지로 이동하여 `Settings` 탭을 클릭합니다.
2.  **Pages 섹션 이동**: 왼쪽 사이드바에서 `Pages`를 클릭합니다.
3.  **Source 설정**: `Build and deployment` 섹션에서 `Source`를 `Deploy from a branch`로 선택합니다.
4.  **Branch 및 Folder 설정**: `Branch` 드롭다운에서 `main` (또는 여러분의 주 브랜치)을 선택하고, `Folder` 드롭다운에서 `/github-deploy`를 선택합니다. 그리고 `Save` 버튼을 클릭합니다.
5.  **배포 확인**: 설정이 저장되면 GitHub Pages가 자동으로 빌드 및 배포를 시작합니다. 배포가 완료되면 페이지 상단에 여러분의 GitHub Pages URL이 표시됩니다. 이 URL을 통해 배포된 런처 페이지에 접근할 수 있습니다.

**GitHub Actions를 통한 배포 (선택 사항)**: 만약 더 복잡한 빌드 또는 배포 로직이 필요하다면, `Source`를 `GitHub Actions`로 설정하고 `.github/workflows` 폴더에 Pages 배포를 위한 워크플로우 파일을 생성할 수 있습니다. 이 경우, `npm run prepare` 명령을 워크플로우 내에서 실행하도록 구성하여 자동화된 빌드 및 배포 파이프라인을 구축할 수 있습니다.

이러한 연결 및 설정 과정을 통해 여러분의 `github-deploy` 프로젝트는 Vercel과 GitHub Pages라는 두 가지 강력한 플랫폼을 통해 전 세계에 서비스될 준비를 마치게 됩니다. 다음 섹션에서는 다양한 프로젝트 유형에 따른 배포 규칙과 고려사항에 대해 설명합니다.





## 9. 다종 프로젝트 케이스별 규칙

`github-deploy` 전략은 다양한 유형의 웹/앱 프로젝트를 단일 배포 환경에서 효율적으로 관리하고 배포할 수 있도록 설계되었습니다. 각 프로젝트의 특성에 따라 `prepare.sh` 스크립트의 동작 방식이나 배포 시 고려해야 할 사항이 달라질 수 있습니다. 이 섹션에서는 주요 프로젝트 유형별 배포 규칙과 에셋 경로 처리 가이드라인에 대해 상세히 설명합니다.

### 정적 사이트 배포 규칙

정적 사이트(Static Sites)는 HTML, CSS, JavaScript, 이미지 등 순수한 정적 파일로만 구성된 웹사이트를 의미합니다. 별도의 빌드 과정이나 런타임 서버가 필요 없는 가장 기본적인 형태의 웹 프로젝트입니다.

*   **`prepare.sh` 동작**: `prepare.sh` 스크립트는 원본 프로젝트 폴더의 내용을 `github-deploy/adapters/<project_name>/` 폴더로 `rsync` 명령을 사용하여 그대로 복제합니다. 이때 `node_modules`, `.git`과 같은 불필요한 파일들은 자동으로 제외됩니다.
*   **경로 보정**: 정적 사이트의 HTML, CSS, JavaScript 파일 내에 리소스(이미지, CSS, JS 파일 등)에 대한 절대 경로(`/<path>`)가 사용되었다면, `prepare.sh` 스크립트가 이를 `./<path>`와 같은 상대 경로로 자동 보정합니다. 이는 GitHub Pages와 같이 서브 경로에서 서비스될 때 리소스 로딩 문제를 방지하는 데 필수적입니다.
*   **주의사항**: CSS 파일 내의 `url()` 함수로 참조되는 이미지 경로 등도 상대 경로로 정확히 지정되어야 합니다. 빌드 도구를 사용하지 않는 경우, 개발자가 직접 경로를 상대 경로로 작성하는 습관을 들이는 것이 좋습니다.

### SPA (React/Vue/Svelte 등) 배포 규칙

SPA(Single Page Application)는 React, Vue, Angular, Svelte 등과 같은 프레임워크로 개발되며, 클라이언트 측 JavaScript를 통해 동적으로 콘텐츠를 렌더링하고 라우팅을 처리합니다. SPA는 배포 전에 빌드 과정을 거쳐 최적화된 정적 파일 번들로 변환됩니다.

*   **`prepare.sh` 동작**: `prepare.sh` 스크립트는 원본 SPA 프로젝트 폴더 내의 빌드 산출물 폴더(일반적으로 `dist` 또는 `build`)를 우선적으로 찾아 `github-deploy/adapters/<project_name>/` 폴더로 복사합니다. 이는 빌드된 최적화된 버전을 직접 배포에 활용하는 방식입니다.
*   **404.html 복사**: SPA의 클라이언트 측 라우팅이 GitHub Pages에서 정상적으로 동작하도록, `prepare.sh` 스크립트는 빌드 산출물 내의 `index.html` 파일을 `404.html`로 복사합니다. 이는 사용자가 특정 경로로 직접 접근하거나 새로고침할 때 404 에러 대신 `index.html`이 로드되어 SPA 라우터가 경로를 처리할 수 있도록 합니다.
*   **빌드 설정**: SPA 프로젝트의 빌드 설정(예: Webpack, Vite, Rollup 설정)에서 `publicPath` 또는 `base` 옵션을 `./` (상대 경로)로 설정하는 것이 중요합니다. 이렇게 하면 빌드 시점에 모든 리소스 경로가 상대 경로로 생성되어 GitHub Pages와 같은 서브 경로 환경에서도 문제없이 동작합니다.
*   **Vercel 라우팅**: Vercel은 `vercel.json`의 `routes` 설정을 통해 SPA의 라우팅을 완벽하게 지원합니다. 특히 `src: "^/adapters/([^/]+)/?(.*)$", dest: "/adapters/$1/$2"`와 같은 규칙은 `adapters` 폴더 내의 SPA가 서브 경로에서도 정상적으로 동작하도록 합니다.

### 백엔드 의존 프로젝트 (전통 서버) 배포 규칙

전통적인 백엔드 서버(예: Node.js, Python Flask/Django, Java Spring 등)에 의존하는 프론트엔드 프로젝트의 경우, `github-deploy`는 프론트엔드 부분만 정적 파일로 배포하고, 백엔드 API 호출은 Vercel의 서버리스 프록시 기능을 통해 처리하는 방식을 제안합니다.

*   **프론트엔드 분리**: 백엔드 의존 프로젝트의 경우, 프론트엔드 부분만 빌드하여 정적 파일로 추출합니다. 이 빌드 산출물을 `prepare.sh`를 통해 `adapters` 폴더로 복사합니다.
*   **API 호출 프록시**: 프론트엔드에서 백엔드 API를 직접 호출하는 대신, `github-deploy/api/proxy.js` 서버리스 함수를 통해 호출하도록 변경합니다. 프론트엔드 코드는 `/api/proxy/your-backend-endpoint`와 같이 호출하고, Vercel 대시보드에서 `PROXY_TARGET` 환경 변수에 실제 백엔드 API의 URL을 설정합니다.
*   **CORS/인증 고려**: 프록시를 사용하더라도 백엔드 서버의 CORS 설정이나 인증 방식(토큰, 세션 등)은 여전히 고려해야 합니다. 프론트엔드에서 필요한 인증 정보를 프록시를 통해 백엔드로 전달할 수 있도록 `api/proxy.js`를 수정해야 할 수도 있습니다.
*   **제한 사항**: `github-deploy`는 정적 파일 호스팅 및 서버리스 함수 기반이므로, 웹소켓이나 장시간 연결이 필요한 백엔드 기능은 직접 지원하지 않습니다. 이러한 기능이 필요한 경우 별도의 백엔드 서버를 배포해야 합니다.

### 에셋 경로 처리 가이드라인

웹 프로젝트에서 이미지, 폰트, 비디오 등 다양한 에셋을 사용하는 것은 일반적입니다. 이러한 에셋의 경로를 올바르게 처리하는 것은 배포 후 리소스 로딩 문제를 방지하는 데 매우 중요합니다.

*   **상대 경로 우선**: HTML, CSS, JavaScript 코드 내에서 에셋을 참조할 때는 항상 `./assets/image.png`와 같은 상대 경로를 사용하는 것을 최우선으로 합니다. 이는 GitHub Pages와 같이 서브 경로에서 서비스될 때 가장 안전한 방법입니다.
*   **빌드 도구의 `publicPath`/`base` 설정**: React, Vue 등 빌드 도구를 사용하는 SPA 프로젝트의 경우, 빌드 설정 파일(예: `webpack.config.js`, `vite.config.js`, `vue.config.js`)에서 `publicPath` 또는 `base` 옵션을 `./`로 설정합니다. 이렇게 하면 빌드된 모든 에셋 경로가 상대 경로로 자동 생성됩니다.
*   **CSS 내 `url()`**: CSS 파일 내에서 `background-image: url("../images/bg.jpg");`와 같이 `url()` 함수를 사용하여 에셋을 참조하는 경우에도 상대 경로를 사용해야 합니다. CSS 파일이 위치한 경로를 기준으로 에셋의 상대 경로를 지정합니다.
*   **루트 경로 사용 시 주의**: 커스텀 도메인을 사용하거나 Vercel과 같이 루트 경로(`https://your-domain.com/`)로 서비스되는 환경에서는 `/assets/image.png`와 같은 절대 경로를 사용해도 문제가 없을 수 있습니다. 하지만 GitHub Pages의 서브 경로 환경을 고려한다면, `prepare.sh` 스크립트의 경로 보정 기능을 활용하거나 빌드 시점에 상대 경로로 변환하는 것이 안전합니다.

이러한 프로젝트 유형별 규칙과 에셋 경로 처리 가이드라인을 준수함으로써, 여러분은 `github-deploy` 전략을 통해 다양한 웹/앱 프로젝트를 성공적으로 배포하고 서비스할 수 있습니다. 다음 섹션에서는 배포 전후에 수행해야 할 품질 체크리스트와 발생 가능한 문제에 대한 해결 가이드를 제공합니다.





## 10. 품질 체크리스트 및 문제 해결 가이드

성공적인 배포를 위해서는 프로젝트를 배포하기 전과 후에 철저한 검증 과정을 거치는 것이 중요합니다. 이 섹션에서는 `github-deploy` 전략을 사용하여 프로젝트를 배포할 때 수행해야 할 품질 체크리스트와, 배포 과정 또는 배포 후에 발생할 수 있는 일반적인 문제들에 대한 해결 가이드를 제공합니다.

### 프로젝트 복제 전/후 체크리스트

#### 프로젝트 복제 전 (원본 프로젝트)

`prepare.sh` 스크립트를 실행하기 전에, 원본 프로젝트가 배포 준비가 되었는지 확인해야 합니다.

*   **로컬 구동/빌드 여부 확인**: 각 프로젝트가 로컬 개발 환경에서 정상적으로 구동되고 빌드되는지 확인합니다. SPA의 경우 `npm run build`와 같은 빌드 명령어가 오류 없이 성공적으로 완료되어야 합니다.
*   **외부 API 엔드포인트 점검**: 프로젝트가 외부 API를 호출하는 경우, 해당 API의 엔드포인트가 올바른지, 접근 가능한지, 그리고 필요한 인증 정보(API 키 등)가 올바르게 설정되어 있는지 확인합니다. 특히 개발 환경과 배포 환경의 API 엔드포인트가 다를 수 있으므로, 환경 변수 등을 통해 유연하게 설정될 수 있도록 준비합니다.
*   **CORS 설정 점검**: 외부 API 호출 시 CORS 문제가 발생할 수 있으므로, 백엔드 API 서버의 CORS 설정이 프론트엔드 도메인을 허용하는지 확인합니다. 만약 백엔드 수정이 어렵다면, Vercel의 `api/proxy.js`와 같은 프록시 솔루션을 사용할 준비를 합니다.

#### `npm run prepare` 후 (`github-deploy/adapters` 폴더)

`prepare.sh` 스크립트 실행 후, `github-deploy/adapters` 폴더 내의 산출물이 올바르게 생성되었는지 확인합니다.

*   **`adapters/*` 안에 `index.html` 존재 확인**: 각 프로젝트의 `adapters/<project_name>/` 폴더 안에 `index.html` 파일이 존재하는지 확인합니다. 이는 웹 서비스의 진입점 역할을 합니다.
*   **SPA는 `404.html` 동시 존재 확인**: SPA 프로젝트의 경우, `index.html`과 함께 `404.html` 파일이 동일한 내용으로 존재하는지 확인합니다. 이는 GitHub Pages에서 SPA 라우팅 문제를 해결하는 데 필수적입니다.
*   **이미지/CSS/JS 200 응답 확인**: 로컬에서 `npm run dev`로 웹 서버를 띄운 후, 브라우저의 개발자 도구(Network 탭)를 사용하여 모든 이미지, CSS, JavaScript 파일이 200 OK 상태 코드로 정상적으로 로드되는지 확인합니다. 404 에러가 발생한다면 경로 문제일 가능성이 높습니다.
*   **상대 경로로 리소스 로드되는지 확인**: 개발자 도구의 Elements 탭에서 `<link>`, `<script>`, `<img>` 태그의 `href`나 `src` 속성 값이 상대 경로(예: `./style.css`, `./images/logo.png`)로 올바르게 변환되었는지 확인합니다. CSS 파일 내의 `url()` 함수로 참조되는 배경 이미지 등도 확인합니다.

### 배포 후 최종 점검 사항

프로젝트를 GitHub Pages 또는 Vercel에 배포한 후에는 실제 서비스 환경에서 최종적인 기능 및 품질 점검을 수행해야 합니다.

*   **GitHub Pages 서브경로에서 브라우저 뒤로가기, 리프레시 시 정상 동작 확인**: GitHub Pages의 서브 경로(예: `username.github.io/repo-name/`)로 배포된 SPA의 경우, 특정 페이지로 이동 후 새로고침하거나 브라우저의 뒤로가기/앞으로가기 버튼을 눌렀을 때 정상적으로 페이지가 로드되고 라우팅이 동작하는지 확인합니다. 404 에러가 발생한다면 `404.html` 설정 또는 상대 경로 문제가 원인일 수 있습니다.
*   **Vercel의 `/api/health` 200 확인**: Vercel에 배포된 경우, `https://your-vercel-domain.vercel.app/api/health` 경로로 접근하여 `{

 "ok": true, "ts": <timestamp> }`와 같은 응답이 오는지 확인합니다. 이는 서버리스 함수가 정상적으로 동작하는지 확인하는 가장 기본적인 방법입니다.
*   **`/api/proxy` 경유 외부 API 호출 검증**: `api/proxy.js`를 통해 외부 API를 호출하는 경우, 실제 프론트엔드 애플리케이션에서 해당 API를 호출하여 데이터가 정상적으로 오고 가는지 확인합니다. 개발자 도구의 Network 탭에서 `/api/proxy`로 시작하는 요청이 200 OK로 응답하는지, 그리고 실제 외부 API로의 요청이 성공적으로 전달되었는지 확인합니다.

### 문제 해결 가이드

배포 과정에서 발생할 수 있는 일반적인 문제들과 그 해결 방안은 다음과 같습니다.

#### GitHub Pages 404 에러

*   **증상**: SPA에서 특정 서브 경로로 직접 접근하거나 새로고침 시 404 에러가 발생합니다.
*   **원인**: `404.html` 파일이 누락되었거나, `index.html`과 동일한 내용으로 복사되지 않았을 수 있습니다. 또는 GitHub Pages의 `Source` 설정에서 `Folder`가 올바르게 지정되지 않았을 수 있습니다.
*   **해결**: `npm run prepare`를 다시 실행하여 `adapters/<project_name>/404.html`이 올바르게 생성되었는지 확인합니다. GitHub 저장소 `Settings > Pages`에서 `Branch`와 `Folder` 설정이 `main` 브랜치의 `/github-deploy` 폴더를 가리키는지 다시 확인합니다.

#### 스타일/이미지 미표시

*   **증상**: 웹사이트가 로드되었지만 CSS 스타일이 적용되지 않거나 이미지가 표시되지 않습니다.
*   **원인**: HTML, CSS, JavaScript 파일 내에서 리소스(CSS, JS, 이미지 등) 경로가 잘못 지정되었을 가능성이 높습니다. 특히 절대 경로(`/style.css`)를 사용하여 GitHub Pages의 서브 경로 환경에서 문제가 발생할 수 있습니다.
*   **해결**: `npm run prepare`를 다시 실행하여 경로 보정이 올바르게 적용되었는지 확인합니다. 브라우저 개발자 도구의 Network 탭에서 404 에러가 발생하는 리소스가 있는지 확인하고, 해당 리소스의 경로를 상대 경로(`./style.css`)로 수정합니다. CSS 파일 내의 `url()` 함수로 참조되는 이미지 경로도 상대 경로로 변경되었는지 확인합니다.

#### Vercel에서만 API OK, Pages에서는 실패

*   **증상**: Vercel에 배포된 버전에서는 외부 API 호출이 정상적으로 동작하지만, GitHub Pages에 배포된 버전에서는 API 호출이 실패합니다.
*   **원인**: GitHub Pages는 서버리스 함수를 직접 지원하지 않습니다. 따라서 `api/proxy.js`와 같은 서버리스 프록시 기능은 Vercel에서만 동작합니다.
*   **해결**: GitHub Pages 환경에서는 프론트엔드에서 직접 외부 API를 호출해야 합니다. 이 경우 외부 API가 CORS를 허용하도록 설정되어 있어야 합니다. 또는, GitHub Pages에서는 API 호출 기능을 비활성화하거나, Vercel 배포 버전을 주 서비스로 사용하는 것을 고려해야 합니다.

#### 커스텀 도메인 문제

*   **증상**: 커스텀 도메인으로 접근 시 웹사이트가 로드되지 않거나, `NET::ERR_CERT_COMMON_NAME_INVALID`와 같은 HTTPS 관련 오류가 발생합니다.
*   **원인**: DNS 설정이 올바르지 않거나, HTTPS 인증서 발급이 완료되지 않았을 수 있습니다.
*   **해결**: 도메인 등록 업체의 DNS 설정에서 `CNAME` 또는 `A` 레코드가 GitHub Pages 또는 Vercel의 올바른 주소를 가리키는지 확인합니다. DNS 변경 사항이 전파되는 데 시간이 걸릴 수 있으므로 잠시 기다립니다. GitHub Pages의 경우 `Settings > Pages`에서 `Custom domain` 설정이 올바른지 확인하고, HTTPS 적용 여부를 확인합니다.

이러한 체크리스트와 문제 해결 가이드를 통해 여러분은 `github-deploy` 전략을 사용하여 프로젝트를 성공적으로 배포하고, 발생 가능한 문제에 효과적으로 대응할 수 있을 것입니다. 다음 섹션에서는 `github-deploy` 전략의 핵심 철학인 '최소 변경 원칙'에 대해 설명합니다.

## 11. 최소 변경 원칙 검증

`github-deploy` 지침서의 가장 근본적인 철학은 '최소 변경 원칙'입니다. 이 원칙은 여러분의 기존 개발 산출물(원본 프로젝트)을 최대한 그대로 유지하면서, 배포 및 서빙에 필요한 변경 사항만을 최소한으로 적용하는 것을 목표로 합니다. 이는 개발자의 작업 부담을 줄이고, 기존 코드베이스의 안정성을 보장하며, 배포 과정의 복잡성을 낮추는 데 기여합니다.

### 기존 코드에 손대지 않기 (원본 폴더는 그대로)

`github-deploy` 전략에서 가장 중요한 점은 여러분의 원본 프로젝트 폴더(예: `app1/`, `web1/`)의 코드를 **절대 수정하지 않는다**는 것입니다. 모든 배포 관련 작업은 `github-deploy` 폴더 내에서 이루어지며, 원본 프로젝트는 오직 `prepare.sh` 스크립트에 의해 복제되거나 빌드 산출물이 참조될 뿐입니다. 이는 다음과 같은 이점을 제공합니다.

*   **개발 독립성**: 개발자는 배포 환경을 고려하지 않고 기존 프로젝트 개발에만 집중할 수 있습니다.
*   **안정성**: 원본 코드베이스가 배포 과정으로 인해 예기치 않게 변경되거나 손상될 위험이 없습니다.
*   **버전 관리 용이성**: 원본 프로젝트의 Git 히스토리와 `github-deploy` 폴더의 Git 히스토리가 독립적으로 관리될 수 있어, 각자의 변경 이력을 명확하게 추적할 수 있습니다.

### 경로 보정 및 라우팅/프록시 설정의 범위

`github-deploy` 전략에서 발생하는 모든 경로 보정, 라우팅, 프록시 설정은 `github-deploy` 폴더 내에서만 이루어집니다. 이는 다음과 같은 의미를 가집니다.

*   **경로 보정**: `prepare.sh` 스크립트에 의한 HTML, CSS, JavaScript 파일 내의 상대 경로 변환은 오직 `github-deploy/adapters/` 폴더 내에 복사된 파일에만 적용됩니다. 원본 프로젝트의 파일은 변경되지 않습니다.
*   **라우팅 설정**: Vercel의 `vercel.json` 파일에 정의된 라우팅 규칙은 `github-deploy` 폴더가 배포될 때만 적용됩니다. 이는 Vercel 플랫폼 자체의 설정이며, 여러분의 프로젝트 코드와는 독립적입니다.
*   **프록시 설정**: `api/proxy.js`와 같은 서버리스 프록시 함수는 `github-deploy` 폴더 내에 존재하며, Vercel 환경에서만 동작합니다. 이는 외부 API 호출을 위한 중간 계층 역할을 하며, 원본 프로젝트의 API 호출 로직을 변경하지 않고도 CORS 문제를 해결할 수 있도록 돕습니다.

이러한 '최소 변경 원칙'은 `github-deploy` 지침서가 제공하는 가장 큰 가치 중 하나입니다. 개발자는 기존의 소중한 개발 산출물을 그대로 유지하면서도, 현대적인 배포 환경의 이점을 최대한 활용할 수 있게 됩니다. 다음 섹션에서는 이 지침서의 모든 내용을 요약하여, `github-deploy` 전략을 바로 실행할 수 있는 간결한 순서를 제공합니다.

## 12. 바로 쓰는 실행 순서 (요약)

지금까지 `github-deploy` 전략의 모든 구성 요소와 상세한 작동 원리에 대해 살펴보았습니다. 이 섹션에서는 여러분이 이 지침서를 바탕으로 즉시 프로젝트를 배포하고 서빙할 수 있도록, 핵심적인 실행 순서를 간결하게 요약하여 제공합니다. 이 순서를 따르면 여러분의 기존 웹/앱 프로젝트를 GitHub Pages 및 Vercel을 통해 전 세계에 공개할 수 있습니다.

1.  **`github-deploy/` 폴더 생성 및 위 파일들 배치**: 여러분의 GitHub 저장소(`repo-root`)의 최상위 경로에 `github-deploy/`라는 이름의 새 폴더를 생성합니다. 그리고 이 지침서에서 설명된 모든 필수 파일들(예: `index.html`, `projects.json`, `vercel.json`, `package.json`, `scripts/`, `api/` 등)을 해당 구조에 맞춰 `github-deploy/` 폴더 내에 배치합니다. 필요하다면 이 지침서의 내용을 복사하여 `github-deploy/README.md` 파일도 생성합니다.

2.  **`projects.json`에 대상 프로젝트들 경로 등록**: `github-deploy/projects.json` 파일을 열고, 여러분이 배포하고자 하는 기존 웹/앱 프로젝트들의 이름과 해당 프로젝트의 `repo-root` 기준 상대 경로를 JSON 형식으로 추가합니다. 예를 들어, `repo-root/my-app/`에 있는 프로젝트라면 `"path": "my-app"`과 같이 등록합니다.

3.  **`npm run prepare`로 어댑터 생성**: 터미널 또는 명령 프롬프트에서 `github-deploy/` 폴더로 이동한 후, 다음 명령어를 실행합니다. 이 명령어는 `projects.json`에 등록된 각 프로젝트의 복사본 또는 빌드 산출물을 `github-deploy/adapters/` 폴더 내에 생성하고, 필요한 경로 보정 및 SPA 404 대응 작업을 자동화합니다.
    ```bash
    cd github-deploy
    npm install # http-server 설치를 위해 필요할 수 있습니다.
    npm run prepare
    ```

4.  **`npm run dev`로 로컬 확인**: `prepare` 스크립트 실행 후, 다음 명령어를 실행하여 로컬 웹 서버를 띄우고 브라우저에서 `http://localhost:5173`으로 접속하여 런처 페이지와 각 프로젝트가 정상적으로 로드되고 동작하는지 확인합니다. 모든 링크, 이미지, 스타일, 스크립트가 올바르게 작동하는지 꼼꼼히 점검합니다.
    ```bash
    npm run dev
    ```

5.  **저장소 푸시 → Vercel 연결 → 배포**: 로컬 확인이 완료되면, `repo-root`로 돌아가 `github-deploy` 폴더의 변경 사항을 Git에 커밋하고 GitHub 원격 저장소로 푸시합니다.
    ```bash
    cd .. # repo-root/ 로 이동
    git add github-deploy
    git commit -m "feat: Add github-deploy adapter and initial projects"
    git push origin main
    ```
    이후 Vercel 대시보드에서 새로운 프로젝트를 생성하고, 여러분의 GitHub 저장소를 연결합니다. `Root Directory`를 `github-deploy/`로, `Build Command`를 `npm run vercel-build`로 설정합니다. 필요한 환경 변수(예: `PROXY_TARGET`)를 추가하고 배포를 시작합니다. Vercel은 자동으로 빌드 및 배포를 수행하며, 이후 커밋 시 자동 재배포됩니다.

6.  **GitHub Pages 연결 (필요 시)**: GitHub Pages를 통해 배포하고자 한다면, GitHub 저장소 `Settings > Pages`에서 `Source`를 `Deploy from a branch`로 설정하고, `Branch`를 `main`, `Folder`를 `/github-deploy`로 지정합니다. 설정 저장 후 GitHub Pages URL을 통해 정상적으로 서비스되는지 확인합니다.

7.  **체크리스트로 링크/라우팅/이미지 최종 점검**: 배포가 완료된 후에는 이 지침서의 '품질 체크리스트 및 문제 해결 가이드' 섹션을 참고하여 실제 배포된 환경에서 모든 기능이 정상적으로 동작하는지 최종 점검합니다. 특히 SPA의 새로고침, 뒤로가기/앞으로가기 기능, 외부 API 호출, 모든 리소스의 로딩 여부 등을 확인합니다.

이 간결한 실행 순서를 따르면, 여러분은 기존의 개발 산출물을 활용하여 빠르고 효율적으로 웹 서비스를 배포하고 관리할 수 있게 될 것입니다. 이 지침서가 여러분의 프로젝트 배포 여정에 큰 도움이 되기를 바랍니다.


